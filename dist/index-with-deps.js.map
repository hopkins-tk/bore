{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap b9adee837d937f2ad333","webpack:///./src/index.js","webpack:///./~/skatejs-dom-diff/dist/index.js"],"names":["h","mount","window","DocumentFragment","Node","Promise","slice","startsWith","key","val","indexOf","shouldBeAttr","handleFunction","Fn","prototype","HTMLElement","name","attrs","node","document","createElement","Object","keys","forEach","attr","setAttribute","chren","appendChild","child","createTextNode","customElements","NodeFilter","body","attachShadow","diff","require","default","enableFlush","fixture","call","mode","flush","matches","query","msMatchesSelector","Wrapper","opts","isStringNode","isRootNode","parentNode","contains","innerHTML","firstElementChild","customElementDefinition","get","localName","shadowRoot","temp","walk","push","nodeType","ELEMENT_NODE","destination","source","root","length","every","skip","map","n","one","all","func","waitFor","wrap","then","delay","resolve","reject","check","ret","e","setTimeout","catch","callback","children","acceptNode","FILTER_ACCEPT","FILTER_SKIP","FILTER_REJECT","tree","createTreeWalker","SHOW_ELEMENT","nextNode","currentNode","elem"],"mappings":"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CA,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA,sCAAqC;AACrC,IAAG;AACH;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH,wEAAuE;AACvE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,oBAAoB;AACnC;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA,gBAAe,yCAAyC;AACxD;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA,mBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,0CAA0C;AACzD;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,EAAC;;AAED;;AAEA;AACA;AACA,sCAAqC;AACrC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,+BAA+B;AAChD;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA,IAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0CAAyC,2CAA2C;AACpF;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAiB,eAAe;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAC;AACD;AACA;;;;;;AAMA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAW;AACX;AACA,YAAW;AACX,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,EAAC;;;;;;;;;;;;;;;;AAgBD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;AAkBA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAoB,kBAAkB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;AACL,yCAAwC;AACxC;AACA;AACA;;AAEA;AACA,WAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA,IAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,2CAA0C;AAC1C;AACA;AACA;AACA;AACA;;AAEA,sFAAqF,aAAa;AAClG;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,+CAA8C,cAAc;;AAE5D,EAAC;AACD","file":"dist/index-with-deps.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bore\"] = factory();\n\telse\n\t\troot[\"bore\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b9adee837d937f2ad333","const { DocumentFragment, Node, Promise } = window;\nconst { slice } = [];\n\nfunction startsWith (key, val) {\n  return key.indexOf(val) === 0;\n}\n\nfunction shouldBeAttr (key, val) {\n  return startsWith(key, 'aria-') || startsWith(key, 'data-');\n}\n\nfunction handleFunction (Fn) {\n  return Fn.prototype instanceof HTMLElement ? new Fn() : Fn();\n}\n\nexport function h (name, attrs, ...chren) {\n  const node = typeof name === 'function' ? handleFunction(name) : document.createElement(name);\n  Object.keys(attrs || []).forEach(attr =>\n    shouldBeAttr(attr, attrs[attr])\n      ? node.setAttribute(attr, attrs[attr])\n      : (node[attr] = attrs[attr]));\n  chren.forEach(child => node.appendChild(child instanceof Node ? child : document.createTextNode(child)));\n  return node;\n}\n\nconst { customElements, HTMLElement, NodeFilter } = window;\nconst { body } = document;\nconst { attachShadow } = HTMLElement.prototype;\nconst { diff } = require('skatejs-dom-diff').default;\n\n// Ensure we can force sync operations in the polyfill.\nif (customElements) {\n  customElements.enableFlush = true;\n}\n\n// Create and add a fixture to append nodes to.\nconst fixture = document.createElement('div');\ndocument.body.appendChild(fixture);\n\n// Override to force mode \"open\" so we can query against all shadow roots.\nHTMLElement.prototype.attachShadow = function () {\n  return attachShadow.call(this, { mode: 'open' });\n};\n\n// Ensures polyfill operations are run sync.\nfunction flush () {\n  if (customElements && typeof customElements.flush === 'function') {\n    customElements.flush();\n  }\n}\n\n// Abstraction for browsers not following the spec.\nfunction matches (node, query) {\n  return (node.matches || node.msMatchesSelector).call(node, query);\n}\n\nclass Wrapper {\n  constructor (node, opts = {}) {\n    this.opts = opts;\n\n    const isStringNode = typeof node === 'string';\n    const isRootNode = !node.parentNode;\n\n    // If the fixture has been removed from the document, re-insert it.\n    if (!body.contains(fixture)) {\n      body.appendChild(fixture);\n    }\n\n    // If this is a new node, clean up the fixture.\n    // Add the node to the fixture so it runs the connectedCallback().\n    if (isRootNode) {\n      fixture.innerHTML = '';\n\n      if (isStringNode) {\n          fixture.innerHTML = node;\n          this.node = fixture.firstElementChild;\n      } else {\n          fixture.appendChild(node);\n          this.node = node;\n      }\n\n      const customElementDefinition = customElements.get(this.node.localName);\n      customElementDefinition && flush();\n    } else {\n      this.node = node;\n    }\n  }\n\n  get shadowRoot () {\n    const { node } = this;\n    return node.shadowRoot || node;\n  }\n\n  all (query) {\n    const { shadowRoot } = this;\n    let temp = [];\n\n    // Custom element constructors\n    if (query.prototype instanceof HTMLElement) {\n      this.walk(\n        shadowRoot,\n        node => node instanceof query,\n        node => temp.push(node)\n      );\n    // Custom filtering function\n    } else if (typeof query === 'function') {\n      this.walk(\n        shadowRoot,\n        query,\n        node => temp.push(node)\n      );\n    // Diffing node trees\n    //\n    // We have to check if the node type is an element rather than checking\n    // instanceof because the ShadyDOM polyfill seems to fail the prototype\n    // chain lookup.\n    } else if (query.nodeType === Node.ELEMENT_NODE) {\n      this.walk(\n        shadowRoot,\n        node => diff({ destination: query, source: node, root: true }).length === 0,\n        node => temp.push(node)\n      );\n    // Using an object as criteria\n    } else if (typeof query === 'object') {\n      const keys = Object.keys(query);\n      if (keys.length === 0) {\n        return temp;\n      }\n      this.walk(\n        shadowRoot,\n        node => keys.every(key => node[key] === query[key]),\n        node => temp.push(node)\n      );\n    // Selector\n    } else if (typeof query === 'string') {\n      this.walk(\n        shadowRoot,\n        node => matches(node, query),\n        node => temp.push(node),\n        { skip: true }\n      );\n    }\n\n    return temp.map(n => new Wrapper(n, this.opts));\n  }\n\n  has (query) {\n    return !!this.one(query);\n  }\n\n  one (query) {\n    return this.all(query)[0];\n  }\n\n  wait (func) {\n    return this.waitFor(wrap => !!wrap.node.shadowRoot).then(func);\n  }\n\n  waitFor (func, { delay } = { delay: 1 }) {\n    return new Promise((resolve, reject) => {\n      const check = () => {\n        const ret = (() => {\n          try {\n            return func(this);\n          } catch (e) {\n            reject(e);\n          }\n        })();\n        if (ret) {\n          resolve(this);\n        } else {\n          setTimeout(check, delay);\n        }\n      };\n      setTimeout(check, delay);\n    }).catch(e => {\n      throw e;\n    });\n  }\n\n  walk (node, query, callback, opts = { root: false, skip: false }) {\n    // The ShadyDOM polyfill creates a shadow root that is a <div /> but is an\n    // instanceof a DocumentFragment. For some reason a tree walker can't\n    // traverse it, so we must traverse each child. Due to this implementation\n    // detail, we must also tell the walker to include the root node, which it\n    // doesn't do with the default implementation.\n    if (node instanceof DocumentFragment) {\n      slice.call(node.children).forEach(child => {\n        this.walk(child, query, callback, {\n          root: true,\n          skip: opts.skip\n        });\n      });\n      return;\n    }\n\n    const acceptNode = node =>\n      query(node)\n        ? NodeFilter.FILTER_ACCEPT\n        : opts.skip ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_REJECT;\n\n    // IE requires a function, standards compliant browsers require an object.\n    acceptNode.acceptNode = acceptNode;\n\n    // Last argument here is for IE.\n    const tree = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, acceptNode, true);\n\n    // Include the main node.\n    if (opts.root && query(node)) {\n      callback(node);\n    }\n\n    // Call user callback for each node.\n    while (tree.nextNode()) {\n      callback(tree.currentNode);\n    }\n  }\n}\n\nexport function mount (elem) {\n  return new Wrapper(elem);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.skatejsDomDiff = global.skatejsDomDiff || {})));\n}(this, (function (exports) {\n\nvar APPEND_CHILD = 1;\nvar REMOVE_CHILD = 2;\nvar REMOVE_ATTRIBUTE = 3;\nvar REPLACE_CHILD = 4;\nvar SET_ATTRIBUTE = 5;\nvar SET_EVENT = 6;\nvar SET_PROPERTY = 7;\nvar TEXT_CONTENT = 8;\n\nvar types = Object.freeze({\n\tAPPEND_CHILD: APPEND_CHILD,\n\tREMOVE_CHILD: REMOVE_CHILD,\n\tREMOVE_ATTRIBUTE: REMOVE_ATTRIBUTE,\n\tREPLACE_CHILD: REPLACE_CHILD,\n\tSET_ATTRIBUTE: SET_ATTRIBUTE,\n\tSET_EVENT: SET_EVENT,\n\tSET_PROPERTY: SET_PROPERTY,\n\tTEXT_CONTENT: TEXT_CONTENT\n});\n\nfunction classToString(obj) {\n  if (typeof obj === 'string') {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.join(' ');\n  }\n\n  return Object.keys(obj).filter(function (key) {\n    return obj[key] ? key : false;\n  }).join(' ');\n}\n\nfunction styleToString(obj) {\n  if (typeof obj === 'string') {\n    return obj;\n  }\n\n  return Object.keys(obj).map(function (key) {\n    return key + ': ' + obj[key] + ';';\n  }).join(' ');\n}\n\nfunction getAccessor(node, name) {\n  if (name === 'class') {\n    return node.className;\n  } else if (name === 'style') {\n    return node.style.cssText;\n    // most things\n  } else if (name !== 'type' && name in node) {\n    return node[name];\n    // real DOM elements\n  } else if (node.getAttribute) {\n    return node.getAttribute(name);\n    // vDOM nodes\n  } else if (node.attributes && node.attributes[name]) {\n    return node.attributes[name].value;\n  }\n}\n\nfunction mapAccessor(node, name, value) {\n  if (name === 'class') {\n    node.className = classToString(value);\n  } else if (name === 'style') {\n    node.style = { cssText: styleToString(value) };\n  }\n}\n\nfunction removeAccessor(node, name) {\n  if (name === 'class') {\n    node.className = '';\n  } else if (name === 'style') {\n    node.style.cssText = '';\n    // most things\n  } else if (name !== 'type' && name in node) {\n    node[name] = '';\n    // real DOM elements\n  } else if (node.removeAttribute) {\n    node.removeAttribute(name);\n    // vDOM nodes\n  } else if (node.attributes) {\n    delete node.attributes[name];\n  }\n}\n\nfunction setAccessor(node, name, value) {\n  if (name === 'class') {\n    node.className = value;\n  } else if (name === 'style') {\n    node.style.cssText = value;\n    // most things\n  } else if (name !== 'type' && name in node || typeof value !== 'string') {\n    // We check if it's undefined or null because IE throws \"invalid argument\"\n    // errors for some types of properties. Essentially this is the same as\n    // removing the accessor.\n    node[name] = value == null ? '' : value;\n    // real DOM elements\n  } else if (node.setAttribute) {\n    node.setAttribute(name, value);\n    // vDOM nodes\n  } else if (node.attributes) {\n    node.attributes[node.attributes.length] = node.attributes[name] = { name: name, value: value };\n  }\n}\n\nvar compareAttributes = function (src, dst) {\n  var srcAttrs = src.attributes;\n  var dstAttrs = dst.attributes;\n  var srcAttrsLen = (srcAttrs || 0) && srcAttrs.length;\n  var dstAttrsLen = (dstAttrs || 0) && dstAttrs.length;\n  var instructions = [];\n\n  // Bail early if possible.\n  if (!srcAttrsLen && !dstAttrsLen) {\n    return instructions;\n  }\n\n  // Merge attributes that exist in source with destination's.\n  for (var a = 0; a < srcAttrsLen; a++) {\n    var srcAttr = srcAttrs[a];\n    var srcAttrName = srcAttr.name;\n    var srcAttrValue = getAccessor(src, srcAttrName);\n    var dstAttr = dstAttrs[srcAttrName];\n    var dstAttrValue = getAccessor(dst, srcAttrName);\n\n    if (!dstAttr) {\n      instructions.push({\n        data: { name: srcAttrName },\n        destination: dst,\n        source: src,\n        type: REMOVE_ATTRIBUTE\n      });\n    } else if (srcAttrValue !== dstAttrValue) {\n      instructions.push({\n        data: { name: srcAttrName, value: dstAttrValue },\n        destination: dst,\n        source: src,\n        type: SET_ATTRIBUTE\n      });\n    }\n  }\n\n  // We only need to worry about setting attributes that don't already exist\n  // in the source.\n  for (var _a = 0; _a < dstAttrsLen; _a++) {\n    var _dstAttr = dstAttrs[_a];\n    var dstAttrName = _dstAttr.name;\n    var _dstAttrValue = getAccessor(dst, dstAttrName);\n    var _srcAttr = srcAttrs[dstAttrName];\n\n    if (!_srcAttr) {\n      instructions.push({\n        data: { name: dstAttrName, value: _dstAttrValue },\n        destination: dst,\n        source: src,\n        type: SET_ATTRIBUTE\n      });\n    }\n  }\n\n  return instructions;\n};\n\n// Because weak map polyfills either are too big or don't use native if\n// available properly.\n\nvar index$1 = 0;\nvar prefix = '__WEAK_MAP_POLYFILL_';\n\nvar WeakMap$1 = (function () {\n  if (typeof WeakMap !== 'undefined') {\n    return WeakMap;\n  }\n\n  function Polyfill() {\n    this.key = prefix + index$1;\n    ++index$1;\n  }\n\n  Polyfill.prototype = {\n    get: function get(obj) {\n      return obj[this.key];\n    },\n    set: function set(obj, val) {\n      obj[this.key] = val;\n    }\n  };\n\n  return Polyfill;\n})();\n\nvar map = new WeakMap$1();\n\nvar eventMap = function (elem) {\n  var events = map.get(elem);\n  events || map.set(elem, events = {});\n  return events;\n};\n\nvar compareEvents = function (src, dst) {\n  var dstEvents = dst.events;\n  var srcEvents = eventMap(src);\n  var instructions = [];\n\n  // Remove any source events that aren't in the destination before seeing if\n  // we need to add any from the destination.\n  if (srcEvents) {\n    for (var name in srcEvents) {\n      if (dstEvents && dstEvents[name] !== srcEvents[name]) {\n        instructions.push({\n          data: { name: name, value: undefined },\n          destination: dst,\n          source: src,\n          type: SET_EVENT\n        });\n      }\n    }\n  }\n\n  // After instructing to remove any old events, we then can instruct to add\n  // new events. This prevents the new events from being removed from earlier\n  // instructions.\n  if (dstEvents) {\n    for (var _name in dstEvents) {\n      var value = dstEvents[_name];\n      if (srcEvents[_name] !== value) {\n        instructions.push({\n          data: { name: _name, value: value },\n          destination: dst,\n          source: src,\n          type: SET_EVENT\n        });\n      }\n    }\n  }\n\n  return instructions;\n};\n\nvar compareElement = function (src, dst) {\n  if (src.tagName === dst.tagName) {\n    return compareAttributes(src, dst).concat(compareEvents(src, dst));\n  }\n};\n\nvar text = function (src, dst) {\n  if (src.textContent === dst.textContent) {\n    return [];\n  }\n\n  return [{\n    destination: dst,\n    source: src,\n    type: TEXT_CONTENT\n  }];\n};\n\nvar NODE_COMMENT = 8;\nvar NODE_ELEMENT = 1;\nvar NODE_TEXT = 3;\n\nvar compareNode = function (src, dst) {\n  var dstType = void 0,\n      srcType = void 0;\n\n  if (!dst || !src) {\n    return;\n  }\n\n  dstType = dst.nodeType;\n  srcType = src.nodeType;\n\n  if (dstType !== srcType) {\n    return;\n  } else if (dstType === NODE_ELEMENT) {\n    return compareElement(src, dst);\n  } else if (dstType === NODE_TEXT) {\n    return text(src, dst);\n  } else if (dstType === NODE_COMMENT) {\n    return text(src, dst);\n  }\n};\n\nvar realNodeMap = new WeakMap$1();\n\nvar _window$1 = window;\nvar Node$1 = _window$1.Node;\n\n\nvar realNode = function (node) {\n  return node instanceof Node$1 ? node : realNodeMap.get(node);\n};\n\nvar _window = window;\nvar Node = _window.Node;\n\n\nfunction diffNode(source, destination) {\n  var nodeInstructions = compareNode(source, destination);\n\n  // If there are instructions (even an empty array) it means the node can be\n  // diffed and doesn't have to be replaced. If the instructions are falsy\n  // it means that the nodes are not similar (cannot be changed) and must be\n  // replaced instead.\n  if (nodeInstructions) {\n    return nodeInstructions.concat(diff({ source: source, destination: destination }));\n  }\n\n  return [{\n    destination: destination,\n    source: source,\n    type: REPLACE_CHILD\n  }];\n}\n\nfunction diff() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var src = opts.source;\n  var dst = opts.destination;\n\n  if (!src || !dst) {\n    return [];\n  }\n\n  var instructions = opts.root ? diffNode(src, dst) : [];\n\n  var srcChs = src.childNodes;\n  var dstChs = dst.childNodes;\n  var srcChsLen = srcChs ? srcChs.length : 0;\n  var dstChsLen = dstChs ? dstChs.length : 0;\n\n  for (var a = 0; a < dstChsLen; a++) {\n    var curSrc = srcChs[a];\n    var curDst = dstChs[a];\n\n    // If there is no matching destination node it means we need to remove the\n    // current source node from the source.\n    if (!curSrc) {\n      instructions.push({\n        destination: dstChs[a],\n        source: src,\n        type: APPEND_CHILD\n      });\n      continue;\n    } else {\n      // Ensure the real node is carried over even if the destination isn't used.\n      // This is used in the render() function to keep track of the real node\n      // that corresponds to a virtual node if a virtual tree is being used.\n      if (!(curDst instanceof Node)) {\n        realNodeMap.set(curDst, realNode(curSrc));\n      }\n    }\n\n    instructions = instructions.concat(diffNode(curSrc, curDst));\n  }\n\n  if (dstChsLen < srcChsLen) {\n    for (var _a = dstChsLen; _a < srcChsLen; _a++) {\n      instructions.push({\n        destination: srcChs[_a],\n        source: src,\n        type: REMOVE_CHILD\n      });\n    }\n  }\n\n  return instructions;\n}\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\nvar asyncGenerator = function () {\n  function AwaitValue(value) {\n    this.value = value;\n  }\n\n  function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n\n        if (value instanceof AwaitValue) {\n          Promise.resolve(value.value).then(function (arg) {\n            resume(\"next\", arg);\n          }, function (arg) {\n            resume(\"throw\", arg);\n          });\n        } else {\n          settle(result.done ? \"return\" : \"normal\", result.value);\n        }\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case \"throw\":\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) {\n    return this._invoke(\"next\", arg);\n  };\n\n  AsyncGenerator.prototype.throw = function (arg) {\n    return this._invoke(\"throw\", arg);\n  };\n\n  AsyncGenerator.prototype.return = function (arg) {\n    return this._invoke(\"return\", arg);\n  };\n\n  return {\n    wrap: function (fn) {\n      return function () {\n        return new AsyncGenerator(fn.apply(this, arguments));\n      };\n    },\n    await: function (value) {\n      return new AwaitValue(value);\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar get$1 = function get$1(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get$1(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar set$1 = function set$1(object, property, value, receiver) {\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent !== null) {\n      set$1(parent, property, value, receiver);\n    }\n  } else if (\"value\" in desc && desc.writable) {\n    desc.value = value;\n  } else {\n    var setter = desc.set;\n\n    if (setter !== undefined) {\n      setter.call(receiver, value);\n    }\n  }\n\n  return value;\n};\n\nvar _window$2 = window;\nvar Node$2 = _window$2.Node;\n\n\nfunction createElement(el) {\n  var realNode = document.createElement(el.tagName);\n  var attributes = el.attributes;\n  var events = el.events;\n  var eventHandlers = eventMap(realNode);\n  var children = el.childNodes;\n\n  if (attributes) {\n    var attributesLen = attributes.length;\n    for (var a = 0; a < attributesLen; a++) {\n      var attr = attributes[a];\n      setAccessor(realNode, attr.name, attr.value);\n    }\n  }\n\n  if (events) {\n    for (var name in events) {\n      realNode.addEventListener(name, eventHandlers[name] = events[name]);\n    }\n  }\n\n  if (children) {\n    var docfrag = document.createDocumentFragment();\n    var childrenLen = children.length;\n\n    for (var _a = 0; _a < childrenLen; _a++) {\n      var ch = children[_a];\n      ch && docfrag.appendChild(render(ch));\n    }\n\n    if (realNode.appendChild) {\n      realNode.appendChild(docfrag);\n    }\n  }\n\n  return realNode;\n}\n\nfunction createText(el) {\n  return document.createTextNode(el.textContent);\n}\n\nfunction render(el) {\n  if (el instanceof Node$2) {\n    return el;\n  }\n  if (Array.isArray(el)) {\n    var _ret = function () {\n      var frag = document.createDocumentFragment();\n      el.forEach(function (item) {\n        return frag.appendChild(render(item));\n      });\n      return {\n        v: frag\n      };\n    }();\n\n    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n  }\n  var realNode = el.tagName ? createElement(el) : createText(el);\n  realNodeMap.set(el, realNode);\n  return realNode;\n}\n\nvar appendChild = function (src, dst) {\n  realNode(src).appendChild(render(dst));\n};\n\nvar removeAttribute = function (src, dst, data) {\n  removeAccessor(realNode(src), data.name);\n};\n\nvar removeChild = function (src, dst) {\n  var realDst = realNode(dst);\n  var realSrc = realNode(src);\n\n  // We don't do parentNode.removeChild because parentNode may report\n  // incorrectly in some prollyfills since it's impossible (?) to spoof.\n  realSrc.removeChild(realDst);\n};\n\nvar replaceChild = function (src, dst) {\n  var realSrc = realNode(src);\n  realSrc && realSrc.parentNode && realSrc.parentNode.replaceChild(render(dst), realSrc);\n};\n\nvar setAttribute = function (src, dst, data) {\n  setAccessor(realNode(src), data.name, data.value);\n};\n\nvar setEvent = function (src, dst, data) {\n  var realSrc = realNode(src);\n  var eventHandlers = eventMap(realSrc);\n  var name = data.name;\n  var prevHandler = eventHandlers[name];\n  var nextHandler = data.value;\n\n  if (typeof prevHandler === 'function') {\n    delete eventHandlers[name];\n    realSrc.removeEventListener(name, prevHandler);\n  }\n\n  if (typeof nextHandler === 'function') {\n    eventHandlers[name] = nextHandler;\n    realSrc.addEventListener(name, nextHandler);\n  }\n};\n\nvar textContent = function (src, dst) {\n  realNode(src).textContent = dst.textContent;\n};\n\nvar patchers = {};\npatchers[APPEND_CHILD] = appendChild;\npatchers[REMOVE_ATTRIBUTE] = removeAttribute;\npatchers[REMOVE_CHILD] = removeChild;\npatchers[REPLACE_CHILD] = replaceChild;\npatchers[SET_ATTRIBUTE] = setAttribute;\npatchers[SET_EVENT] = setEvent;\npatchers[TEXT_CONTENT] = textContent;\n\nfunction patch(instruction) {\n  patchers[instruction.type](instruction.source, instruction.destination, instruction.data);\n}\n\nvar patch$1 = function (instructions) {\n  instructions.forEach(patch);\n};\n\nvar merge = function (opts) {\n  var inst = diff(opts);\n  patch$1(inst);\n  return inst;\n};\n\nfunction createTextNode(item) {\n  return {\n    nodeType: 3,\n    textContent: item\n  };\n}\n\nfunction separateData(obj) {\n  var attrs = {};\n  var events = {};\n  var node = {};\n  var attrIdx = 0;\n\n  for (var name in obj) {\n    var value = obj[name];\n\n    if (name.indexOf('on') === 0) {\n      events[name.substring(2)] = value;\n    } else {\n      attrs[attrIdx++] = attrs[name] = { name: name, value: value };\n      mapAccessor(node, name, value);\n    }\n  }\n\n  attrs.length = attrIdx;\n  return { attrs: attrs, events: events, node: node };\n}\n\nfunction ensureNodes(arr) {\n  var out = [];\n  if (!Array.isArray(arr)) {\n    arr = [arr];\n  }\n  arr.filter(Boolean).forEach(function (item) {\n    if (Array.isArray(item)) {\n      out = out.concat(ensureNodes(item));\n    } else if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {\n      out.push(translateFromReact(item));\n    } else {\n      out.push(createTextNode(item));\n    }\n  });\n  return out;\n}\n\nfunction ensureTagName(name) {\n  return (typeof name === 'function' ? name.id || name.name : name).toUpperCase();\n}\n\nfunction isChildren(arg) {\n  return arg && (typeof arg === 'string' || Array.isArray(arg) || typeof arg.nodeType === 'number' || isReactNode(arg));\n}\n\nfunction isReactNode(item) {\n  return item && item.type && item.props;\n}\n\nfunction translateFromReact(item) {\n  if (isReactNode(item)) {\n    var props = item.props;\n    var chren = ensureNodes(props.children);\n    delete props.children;\n    return {\n      nodeType: 1,\n      tagName: item.type,\n      attributes: props,\n      childNodes: chren\n    };\n  }\n  return item;\n}\n\nfunction element(name) {\n  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var isAttrsNode = isChildren(attrs);\n  var data = separateData(isAttrsNode ? {} : attrs);\n  var node = data.node;\n  node.nodeType = 1;\n  node.tagName = ensureTagName(name);\n  node.attributes = data.attrs;\n  node.events = data.events;\n\n  for (var _len = arguments.length, chren = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    chren[_key - 2] = arguments[_key];\n  }\n\n  node.childNodes = ensureNodes(isAttrsNode ? [attrs].concat(chren) : chren);\n  return node;\n}\n\n// Add an array factory that returns an array of virtual nodes.\nelement.array = ensureNodes;\n\n// Generate built-in factories.\n['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'bgsound', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'command', 'content', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'element', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'image', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'multicol', 'nav', 'nobr', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'script', 'section', 'select', 'shadow', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr'].forEach(function (tag) {\n  element[tag] = element.bind(null, tag);\n});\n\nfunction removeChildNodes(elem) {\n  while (elem.firstChild) {\n    var first = elem.firstChild;\n    first.parentNode.removeChild(first);\n  }\n}\n\nvar mount = function (elem, tree) {\n  removeChildNodes(elem);\n  elem.appendChild(render(tree));\n};\n\nvar _window$3 = window;\nvar Node$3 = _window$3.Node;\n\nvar oldTreeMap = new WeakMap$1();\n\nvar render$1 = function (render) {\n  return function (elem) {\n    elem = elem instanceof Node$3 ? elem : this;\n\n    if (!(elem instanceof Node$3)) {\n      throw new Error('No node provided to diff renderer as either the first argument or the context.');\n    }\n\n    // Create a new element to house the new tree since we diff / mount fragments.\n    var newTree = element('div', null, render(elem));\n    var oldTree = oldTreeMap.get(elem);\n\n    if (oldTree) {\n      merge({\n        destination: newTree,\n        source: oldTree\n      });\n    } else {\n      mount(elem, newTree.childNodes);\n    }\n\n    oldTreeMap.set(elem, newTree);\n  };\n};\n\nvar vdom = {\n  dom: render,\n  element: element,\n  mount: mount,\n  text: createTextNode\n};\n\nvar version = '0.3.1';\n\nvar index = {\n  diff: diff,\n  merge: merge,\n  patch: patch$1,\n  render: render$1,\n  types: types,\n  vdom: vdom,\n  version: version\n};\n\nexports['default'] = index;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=index.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/skatejs-dom-diff/dist/index.js\n// module id = 1\n// module chunks = 0 1"],"sourceRoot":""}