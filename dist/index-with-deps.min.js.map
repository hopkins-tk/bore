{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///dist/index-with-deps.min.js","webpack:///webpack/bootstrap b9adee837d937f2ad333?c86c","webpack:///./src/index.js?9552","webpack:///./~/skatejs-dom-diff/dist/index.js?a359"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","startsWith","key","val","indexOf","shouldBeAttr","handleFunction","Fn","prototype","HTMLElement","h","name","attrs","node","document","createElement","Object","keys","forEach","attr","setAttribute","_len","arguments","length","chren","Array","_key","child","appendChild","Node","createTextNode","flush","customElements","matches","query","msMatchesSelector","mount","elem","Wrapper","defineProperty","value","_typeof","Symbol","iterator","obj","constructor","_createClass","defineProperties","target","props","i","descriptor","enumerable","configurable","writable","protoProps","staticProps","_window","window","DocumentFragment","Promise","slice","_window2","NodeFilter","_document","body","attachShadow","diff","default","enableFlush","fixture","mode","opts","undefined","isStringNode","isRootNode","parentNode","contains","innerHTML","firstElementChild","customElementDefinition","get","localName","_this","shadowRoot","temp","walk","push","nodeType","ELEMENT_NODE","destination","source","_ret","v","every","skip","map","n","one","all","func","waitFor","wrap","then","_this2","_ref","delay","resolve","reject","check","ret","e","setTimeout","catch","callback","_this3","children","acceptNode","FILTER_ACCEPT","FILTER_SKIP","FILTER_REJECT","tree","createTreeWalker","SHOW_ELEMENT","nextNode","currentNode","global","classToString","isArray","join","filter","styleToString","getAccessor","className","style","cssText","getAttribute","attributes","mapAccessor","removeAccessor","removeAttribute","setAccessor","diffNode","nodeInstructions","compareNode","concat","type","REPLACE_CHILD","src","dst","instructions","srcChs","childNodes","dstChs","srcChsLen","dstChsLen","a","curSrc","curDst","realNodeMap","set","realNode","APPEND_CHILD","_a","REMOVE_CHILD","el","tagName","events","eventHandlers","eventMap","attributesLen","addEventListener","docfrag","createDocumentFragment","childrenLen","ch","render","createText","textContent","Node$2","frag","item","patch","instruction","patchers","data","separateData","attrIdx","substring","ensureNodes","arr","out","Boolean","translateFromReact","ensureTagName","toUpperCase","isChildren","arg","isReactNode","element","isAttrsNode","removeChildNodes","firstChild","first","removeChild","REMOVE_ATTRIBUTE","SET_ATTRIBUTE","SET_EVENT","SET_PROPERTY","TEXT_CONTENT","types","freeze","compareAttributes","srcAttrs","dstAttrs","srcAttrsLen","dstAttrsLen","srcAttr","srcAttrName","srcAttrValue","dstAttr","dstAttrValue","_dstAttr","dstAttrName","_dstAttrValue","_srcAttr","index$1","prefix","WeakMap$1","Polyfill","WeakMap","compareEvents","dstEvents","srcEvents","_name","compareElement","text","NODE_COMMENT","NODE_ELEMENT","NODE_TEXT","dstType","srcType","_window$1","Node$1","_window$2","AwaitValue","AsyncGenerator","gen","send","request","next","back","front","resume","result","settle","done","err","_invoke","return","asyncIterator","throw","fn","apply","await","realDst","realSrc","replaceChild","setEvent","prevHandler","nextHandler","removeEventListener","patch$1","merge","inst","array","tag","bind","_window$3","Node$3","oldTreeMap","render$1","Error","newTree","oldTree","vdom","dom","version","index"],"mappings":"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","file":"dist/index-with-deps.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bore\"] = factory();\n\telse\n\t\troot[\"bore\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"bore\"] = factory();\n\telse\n\t\troot[\"bore\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\texports.h = h;\n\texports.mount = mount;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar _window = window,\n\t    DocumentFragment = _window.DocumentFragment,\n\t    Node = _window.Node,\n\t    Promise = _window.Promise;\n\tvar slice = [].slice;\n\t\n\t\n\tfunction startsWith(key, val) {\n\t  return key.indexOf(val) === 0;\n\t}\n\t\n\tfunction shouldBeAttr(key, val) {\n\t  return startsWith(key, 'aria-') || startsWith(key, 'data-');\n\t}\n\t\n\tfunction handleFunction(Fn) {\n\t  return Fn.prototype instanceof HTMLElement ? new Fn() : Fn();\n\t}\n\t\n\tfunction h(name, attrs) {\n\t  var node = typeof name === 'function' ? handleFunction(name) : document.createElement(name);\n\t  Object.keys(attrs || []).forEach(function (attr) {\n\t    return shouldBeAttr(attr, attrs[attr]) ? node.setAttribute(attr, attrs[attr]) : node[attr] = attrs[attr];\n\t  });\n\t\n\t  for (var _len = arguments.length, chren = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t    chren[_key - 2] = arguments[_key];\n\t  }\n\t\n\t  chren.forEach(function (child) {\n\t    return node.appendChild(child instanceof Node ? child : document.createTextNode(child));\n\t  });\n\t  return node;\n\t}\n\t\n\tvar _window2 = window,\n\t    customElements = _window2.customElements,\n\t    HTMLElement = _window2.HTMLElement,\n\t    NodeFilter = _window2.NodeFilter;\n\tvar _document = document,\n\t    body = _document.body;\n\tvar attachShadow = HTMLElement.prototype.attachShadow;\n\t\n\tvar diff = __webpack_require__(1).default.diff;\n\t\n\t// Ensure we can force sync operations in the polyfill.\n\t\n\t\n\tif (customElements) {\n\t  customElements.enableFlush = true;\n\t}\n\t\n\t// Create and add a fixture to append nodes to.\n\tvar fixture = document.createElement('div');\n\tdocument.body.appendChild(fixture);\n\t\n\t// Override to force mode \"open\" so we can query against all shadow roots.\n\tHTMLElement.prototype.attachShadow = function () {\n\t  return attachShadow.call(this, { mode: 'open' });\n\t};\n\t\n\t// Ensures polyfill operations are run sync.\n\tfunction flush() {\n\t  if (customElements && typeof customElements.flush === 'function') {\n\t    customElements.flush();\n\t  }\n\t}\n\t\n\t// Abstraction for browsers not following the spec.\n\tfunction matches(node, query) {\n\t  return (node.matches || node.msMatchesSelector).call(node, query);\n\t}\n\t\n\tvar Wrapper = function () {\n\t  function Wrapper(node) {\n\t    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t    _classCallCheck(this, Wrapper);\n\t\n\t    this.opts = opts;\n\t\n\t    var isStringNode = typeof node === 'string';\n\t    var isRootNode = !node.parentNode;\n\t\n\t    // If the fixture has been removed from the document, re-insert it.\n\t    if (!body.contains(fixture)) {\n\t      body.appendChild(fixture);\n\t    }\n\t\n\t    // If this is a new node, clean up the fixture.\n\t    // Add the node to the fixture so it runs the connectedCallback().\n\t    if (isRootNode) {\n\t      fixture.innerHTML = '';\n\t\n\t      if (isStringNode) {\n\t        fixture.innerHTML = node;\n\t        this.node = fixture.firstElementChild;\n\t      } else {\n\t        fixture.appendChild(node);\n\t        this.node = node;\n\t      }\n\t\n\t      var customElementDefinition = customElements.get(this.node.localName);\n\t      customElementDefinition && flush();\n\t    } else {\n\t      this.node = node;\n\t    }\n\t  }\n\t\n\t  _createClass(Wrapper, [{\n\t    key: 'all',\n\t    value: function all(query) {\n\t      var _this = this;\n\t\n\t      var shadowRoot = this.shadowRoot;\n\t\n\t      var temp = [];\n\t\n\t      // Custom element constructors\n\t      if (query.prototype instanceof HTMLElement) {\n\t        this.walk(shadowRoot, function (node) {\n\t          return node instanceof query;\n\t        }, function (node) {\n\t          return temp.push(node);\n\t        });\n\t        // Custom filtering function\n\t      } else if (typeof query === 'function') {\n\t        this.walk(shadowRoot, query, function (node) {\n\t          return temp.push(node);\n\t        });\n\t        // Diffing node trees\n\t        //\n\t        // We have to check if the node type is an element rather than checking\n\t        // instanceof because the ShadyDOM polyfill seems to fail the prototype\n\t        // chain lookup.\n\t      } else if (query.nodeType === Node.ELEMENT_NODE) {\n\t        this.walk(shadowRoot, function (node) {\n\t          return diff({ destination: query, source: node, root: true }).length === 0;\n\t        }, function (node) {\n\t          return temp.push(node);\n\t        });\n\t        // Using an object as criteria\n\t      } else if ((typeof query === 'undefined' ? 'undefined' : _typeof(query)) === 'object') {\n\t        var _ret = function () {\n\t          var keys = Object.keys(query);\n\t          if (keys.length === 0) {\n\t            return {\n\t              v: temp\n\t            };\n\t          }\n\t          _this.walk(shadowRoot, function (node) {\n\t            return keys.every(function (key) {\n\t              return node[key] === query[key];\n\t            });\n\t          }, function (node) {\n\t            return temp.push(node);\n\t          });\n\t          // Selector\n\t        }();\n\t\n\t        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t      } else if (typeof query === 'string') {\n\t        this.walk(shadowRoot, function (node) {\n\t          return matches(node, query);\n\t        }, function (node) {\n\t          return temp.push(node);\n\t        }, { skip: true });\n\t      }\n\t\n\t      return temp.map(function (n) {\n\t        return new Wrapper(n, _this.opts);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'has',\n\t    value: function has(query) {\n\t      return !!this.one(query);\n\t    }\n\t  }, {\n\t    key: 'one',\n\t    value: function one(query) {\n\t      return this.all(query)[0];\n\t    }\n\t  }, {\n\t    key: 'wait',\n\t    value: function wait(func) {\n\t      return this.waitFor(function (wrap) {\n\t        return !!wrap.node.shadowRoot;\n\t      }).then(func);\n\t    }\n\t  }, {\n\t    key: 'waitFor',\n\t    value: function waitFor(func) {\n\t      var _this2 = this;\n\t\n\t      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { delay: 1 },\n\t          delay = _ref.delay;\n\t\n\t      return new Promise(function (resolve, reject) {\n\t        var check = function check() {\n\t          var ret = function () {\n\t            try {\n\t              return func(_this2);\n\t            } catch (e) {\n\t              reject(e);\n\t            }\n\t          }();\n\t          if (ret) {\n\t            resolve(_this2);\n\t          } else {\n\t            setTimeout(check, delay);\n\t          }\n\t        };\n\t        setTimeout(check, delay);\n\t      }).catch(function (e) {\n\t        throw e;\n\t      });\n\t    }\n\t  }, {\n\t    key: 'walk',\n\t    value: function walk(node, query, callback) {\n\t      var _this3 = this;\n\t\n\t      var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : { root: false, skip: false };\n\t\n\t      // The ShadyDOM polyfill creates a shadow root that is a <div /> but is an\n\t      // instanceof a DocumentFragment. For some reason a tree walker can't\n\t      // traverse it, so we must traverse each child. Due to this implementation\n\t      // detail, we must also tell the walker to include the root node, which it\n\t      // doesn't do with the default implementation.\n\t      if (node instanceof DocumentFragment) {\n\t        slice.call(node.children).forEach(function (child) {\n\t          _this3.walk(child, query, callback, {\n\t            root: true,\n\t            skip: opts.skip\n\t          });\n\t        });\n\t        return;\n\t      }\n\t\n\t      var acceptNode = function acceptNode(node) {\n\t        return query(node) ? NodeFilter.FILTER_ACCEPT : opts.skip ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_REJECT;\n\t      };\n\t\n\t      // IE requires a function, standards compliant browsers require an object.\n\t      acceptNode.acceptNode = acceptNode;\n\t\n\t      // Last argument here is for IE.\n\t      var tree = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, acceptNode, true);\n\t\n\t      // Include the main node.\n\t      if (opts.root && query(node)) {\n\t        callback(node);\n\t      }\n\t\n\t      // Call user callback for each node.\n\t      while (tree.nextNode()) {\n\t        callback(tree.currentNode);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'shadowRoot',\n\t    get: function get() {\n\t      var node = this.node;\n\t\n\t      return node.shadowRoot || node;\n\t    }\n\t  }]);\n\t\n\t  return Wrapper;\n\t}();\n\t\n\tfunction mount(elem) {\n\t  return new Wrapper(elem);\n\t}\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (global, factory) {\n\t   true ? factory(exports) :\n\t  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t  (factory((global.skatejsDomDiff = global.skatejsDomDiff || {})));\n\t}(this, (function (exports) {\n\t\n\tvar APPEND_CHILD = 1;\n\tvar REMOVE_CHILD = 2;\n\tvar REMOVE_ATTRIBUTE = 3;\n\tvar REPLACE_CHILD = 4;\n\tvar SET_ATTRIBUTE = 5;\n\tvar SET_EVENT = 6;\n\tvar SET_PROPERTY = 7;\n\tvar TEXT_CONTENT = 8;\n\t\n\tvar types = Object.freeze({\n\t\tAPPEND_CHILD: APPEND_CHILD,\n\t\tREMOVE_CHILD: REMOVE_CHILD,\n\t\tREMOVE_ATTRIBUTE: REMOVE_ATTRIBUTE,\n\t\tREPLACE_CHILD: REPLACE_CHILD,\n\t\tSET_ATTRIBUTE: SET_ATTRIBUTE,\n\t\tSET_EVENT: SET_EVENT,\n\t\tSET_PROPERTY: SET_PROPERTY,\n\t\tTEXT_CONTENT: TEXT_CONTENT\n\t});\n\t\n\tfunction classToString(obj) {\n\t  if (typeof obj === 'string') {\n\t    return obj;\n\t  }\n\t\n\t  if (Array.isArray(obj)) {\n\t    return obj.join(' ');\n\t  }\n\t\n\t  return Object.keys(obj).filter(function (key) {\n\t    return obj[key] ? key : false;\n\t  }).join(' ');\n\t}\n\t\n\tfunction styleToString(obj) {\n\t  if (typeof obj === 'string') {\n\t    return obj;\n\t  }\n\t\n\t  return Object.keys(obj).map(function (key) {\n\t    return key + ': ' + obj[key] + ';';\n\t  }).join(' ');\n\t}\n\t\n\tfunction getAccessor(node, name) {\n\t  if (name === 'class') {\n\t    return node.className;\n\t  } else if (name === 'style') {\n\t    return node.style.cssText;\n\t    // most things\n\t  } else if (name !== 'type' && name in node) {\n\t    return node[name];\n\t    // real DOM elements\n\t  } else if (node.getAttribute) {\n\t    return node.getAttribute(name);\n\t    // vDOM nodes\n\t  } else if (node.attributes && node.attributes[name]) {\n\t    return node.attributes[name].value;\n\t  }\n\t}\n\t\n\tfunction mapAccessor(node, name, value) {\n\t  if (name === 'class') {\n\t    node.className = classToString(value);\n\t  } else if (name === 'style') {\n\t    node.style = { cssText: styleToString(value) };\n\t  }\n\t}\n\t\n\tfunction removeAccessor(node, name) {\n\t  if (name === 'class') {\n\t    node.className = '';\n\t  } else if (name === 'style') {\n\t    node.style.cssText = '';\n\t    // most things\n\t  } else if (name !== 'type' && name in node) {\n\t    node[name] = '';\n\t    // real DOM elements\n\t  } else if (node.removeAttribute) {\n\t    node.removeAttribute(name);\n\t    // vDOM nodes\n\t  } else if (node.attributes) {\n\t    delete node.attributes[name];\n\t  }\n\t}\n\t\n\tfunction setAccessor(node, name, value) {\n\t  if (name === 'class') {\n\t    node.className = value;\n\t  } else if (name === 'style') {\n\t    node.style.cssText = value;\n\t    // most things\n\t  } else if (name !== 'type' && name in node || typeof value !== 'string') {\n\t    // We check if it's undefined or null because IE throws \"invalid argument\"\n\t    // errors for some types of properties. Essentially this is the same as\n\t    // removing the accessor.\n\t    node[name] = value == null ? '' : value;\n\t    // real DOM elements\n\t  } else if (node.setAttribute) {\n\t    node.setAttribute(name, value);\n\t    // vDOM nodes\n\t  } else if (node.attributes) {\n\t    node.attributes[node.attributes.length] = node.attributes[name] = { name: name, value: value };\n\t  }\n\t}\n\t\n\tvar compareAttributes = function (src, dst) {\n\t  var srcAttrs = src.attributes;\n\t  var dstAttrs = dst.attributes;\n\t  var srcAttrsLen = (srcAttrs || 0) && srcAttrs.length;\n\t  var dstAttrsLen = (dstAttrs || 0) && dstAttrs.length;\n\t  var instructions = [];\n\t\n\t  // Bail early if possible.\n\t  if (!srcAttrsLen && !dstAttrsLen) {\n\t    return instructions;\n\t  }\n\t\n\t  // Merge attributes that exist in source with destination's.\n\t  for (var a = 0; a < srcAttrsLen; a++) {\n\t    var srcAttr = srcAttrs[a];\n\t    var srcAttrName = srcAttr.name;\n\t    var srcAttrValue = getAccessor(src, srcAttrName);\n\t    var dstAttr = dstAttrs[srcAttrName];\n\t    var dstAttrValue = getAccessor(dst, srcAttrName);\n\t\n\t    if (!dstAttr) {\n\t      instructions.push({\n\t        data: { name: srcAttrName },\n\t        destination: dst,\n\t        source: src,\n\t        type: REMOVE_ATTRIBUTE\n\t      });\n\t    } else if (srcAttrValue !== dstAttrValue) {\n\t      instructions.push({\n\t        data: { name: srcAttrName, value: dstAttrValue },\n\t        destination: dst,\n\t        source: src,\n\t        type: SET_ATTRIBUTE\n\t      });\n\t    }\n\t  }\n\t\n\t  // We only need to worry about setting attributes that don't already exist\n\t  // in the source.\n\t  for (var _a = 0; _a < dstAttrsLen; _a++) {\n\t    var _dstAttr = dstAttrs[_a];\n\t    var dstAttrName = _dstAttr.name;\n\t    var _dstAttrValue = getAccessor(dst, dstAttrName);\n\t    var _srcAttr = srcAttrs[dstAttrName];\n\t\n\t    if (!_srcAttr) {\n\t      instructions.push({\n\t        data: { name: dstAttrName, value: _dstAttrValue },\n\t        destination: dst,\n\t        source: src,\n\t        type: SET_ATTRIBUTE\n\t      });\n\t    }\n\t  }\n\t\n\t  return instructions;\n\t};\n\t\n\t// Because weak map polyfills either are too big or don't use native if\n\t// available properly.\n\t\n\tvar index$1 = 0;\n\tvar prefix = '__WEAK_MAP_POLYFILL_';\n\t\n\tvar WeakMap$1 = (function () {\n\t  if (typeof WeakMap !== 'undefined') {\n\t    return WeakMap;\n\t  }\n\t\n\t  function Polyfill() {\n\t    this.key = prefix + index$1;\n\t    ++index$1;\n\t  }\n\t\n\t  Polyfill.prototype = {\n\t    get: function get(obj) {\n\t      return obj[this.key];\n\t    },\n\t    set: function set(obj, val) {\n\t      obj[this.key] = val;\n\t    }\n\t  };\n\t\n\t  return Polyfill;\n\t})();\n\t\n\tvar map = new WeakMap$1();\n\t\n\tvar eventMap = function (elem) {\n\t  var events = map.get(elem);\n\t  events || map.set(elem, events = {});\n\t  return events;\n\t};\n\t\n\tvar compareEvents = function (src, dst) {\n\t  var dstEvents = dst.events;\n\t  var srcEvents = eventMap(src);\n\t  var instructions = [];\n\t\n\t  // Remove any source events that aren't in the destination before seeing if\n\t  // we need to add any from the destination.\n\t  if (srcEvents) {\n\t    for (var name in srcEvents) {\n\t      if (dstEvents && dstEvents[name] !== srcEvents[name]) {\n\t        instructions.push({\n\t          data: { name: name, value: undefined },\n\t          destination: dst,\n\t          source: src,\n\t          type: SET_EVENT\n\t        });\n\t      }\n\t    }\n\t  }\n\t\n\t  // After instructing to remove any old events, we then can instruct to add\n\t  // new events. This prevents the new events from being removed from earlier\n\t  // instructions.\n\t  if (dstEvents) {\n\t    for (var _name in dstEvents) {\n\t      var value = dstEvents[_name];\n\t      if (srcEvents[_name] !== value) {\n\t        instructions.push({\n\t          data: { name: _name, value: value },\n\t          destination: dst,\n\t          source: src,\n\t          type: SET_EVENT\n\t        });\n\t      }\n\t    }\n\t  }\n\t\n\t  return instructions;\n\t};\n\t\n\tvar compareElement = function (src, dst) {\n\t  if (src.tagName === dst.tagName) {\n\t    return compareAttributes(src, dst).concat(compareEvents(src, dst));\n\t  }\n\t};\n\t\n\tvar text = function (src, dst) {\n\t  if (src.textContent === dst.textContent) {\n\t    return [];\n\t  }\n\t\n\t  return [{\n\t    destination: dst,\n\t    source: src,\n\t    type: TEXT_CONTENT\n\t  }];\n\t};\n\t\n\tvar NODE_COMMENT = 8;\n\tvar NODE_ELEMENT = 1;\n\tvar NODE_TEXT = 3;\n\t\n\tvar compareNode = function (src, dst) {\n\t  var dstType = void 0,\n\t      srcType = void 0;\n\t\n\t  if (!dst || !src) {\n\t    return;\n\t  }\n\t\n\t  dstType = dst.nodeType;\n\t  srcType = src.nodeType;\n\t\n\t  if (dstType !== srcType) {\n\t    return;\n\t  } else if (dstType === NODE_ELEMENT) {\n\t    return compareElement(src, dst);\n\t  } else if (dstType === NODE_TEXT) {\n\t    return text(src, dst);\n\t  } else if (dstType === NODE_COMMENT) {\n\t    return text(src, dst);\n\t  }\n\t};\n\t\n\tvar realNodeMap = new WeakMap$1();\n\t\n\tvar _window$1 = window;\n\tvar Node$1 = _window$1.Node;\n\t\n\t\n\tvar realNode = function (node) {\n\t  return node instanceof Node$1 ? node : realNodeMap.get(node);\n\t};\n\t\n\tvar _window = window;\n\tvar Node = _window.Node;\n\t\n\t\n\tfunction diffNode(source, destination) {\n\t  var nodeInstructions = compareNode(source, destination);\n\t\n\t  // If there are instructions (even an empty array) it means the node can be\n\t  // diffed and doesn't have to be replaced. If the instructions are falsy\n\t  // it means that the nodes are not similar (cannot be changed) and must be\n\t  // replaced instead.\n\t  if (nodeInstructions) {\n\t    return nodeInstructions.concat(diff({ source: source, destination: destination }));\n\t  }\n\t\n\t  return [{\n\t    destination: destination,\n\t    source: source,\n\t    type: REPLACE_CHILD\n\t  }];\n\t}\n\t\n\tfunction diff() {\n\t  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t  var src = opts.source;\n\t  var dst = opts.destination;\n\t\n\t  if (!src || !dst) {\n\t    return [];\n\t  }\n\t\n\t  var instructions = opts.root ? diffNode(src, dst) : [];\n\t\n\t  var srcChs = src.childNodes;\n\t  var dstChs = dst.childNodes;\n\t  var srcChsLen = srcChs ? srcChs.length : 0;\n\t  var dstChsLen = dstChs ? dstChs.length : 0;\n\t\n\t  for (var a = 0; a < dstChsLen; a++) {\n\t    var curSrc = srcChs[a];\n\t    var curDst = dstChs[a];\n\t\n\t    // If there is no matching destination node it means we need to remove the\n\t    // current source node from the source.\n\t    if (!curSrc) {\n\t      instructions.push({\n\t        destination: dstChs[a],\n\t        source: src,\n\t        type: APPEND_CHILD\n\t      });\n\t      continue;\n\t    } else {\n\t      // Ensure the real node is carried over even if the destination isn't used.\n\t      // This is used in the render() function to keep track of the real node\n\t      // that corresponds to a virtual node if a virtual tree is being used.\n\t      if (!(curDst instanceof Node)) {\n\t        realNodeMap.set(curDst, realNode(curSrc));\n\t      }\n\t    }\n\t\n\t    instructions = instructions.concat(diffNode(curSrc, curDst));\n\t  }\n\t\n\t  if (dstChsLen < srcChsLen) {\n\t    for (var _a = dstChsLen; _a < srcChsLen; _a++) {\n\t      instructions.push({\n\t        destination: srcChs[_a],\n\t        source: src,\n\t        type: REMOVE_CHILD\n\t      });\n\t    }\n\t  }\n\t\n\t  return instructions;\n\t}\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n\t  return typeof obj;\n\t} : function (obj) {\n\t  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n\t};\n\t\n\t\n\t\n\t\n\t\n\tvar asyncGenerator = function () {\n\t  function AwaitValue(value) {\n\t    this.value = value;\n\t  }\n\t\n\t  function AsyncGenerator(gen) {\n\t    var front, back;\n\t\n\t    function send(key, arg) {\n\t      return new Promise(function (resolve, reject) {\n\t        var request = {\n\t          key: key,\n\t          arg: arg,\n\t          resolve: resolve,\n\t          reject: reject,\n\t          next: null\n\t        };\n\t\n\t        if (back) {\n\t          back = back.next = request;\n\t        } else {\n\t          front = back = request;\n\t          resume(key, arg);\n\t        }\n\t      });\n\t    }\n\t\n\t    function resume(key, arg) {\n\t      try {\n\t        var result = gen[key](arg);\n\t        var value = result.value;\n\t\n\t        if (value instanceof AwaitValue) {\n\t          Promise.resolve(value.value).then(function (arg) {\n\t            resume(\"next\", arg);\n\t          }, function (arg) {\n\t            resume(\"throw\", arg);\n\t          });\n\t        } else {\n\t          settle(result.done ? \"return\" : \"normal\", result.value);\n\t        }\n\t      } catch (err) {\n\t        settle(\"throw\", err);\n\t      }\n\t    }\n\t\n\t    function settle(type, value) {\n\t      switch (type) {\n\t        case \"return\":\n\t          front.resolve({\n\t            value: value,\n\t            done: true\n\t          });\n\t          break;\n\t\n\t        case \"throw\":\n\t          front.reject(value);\n\t          break;\n\t\n\t        default:\n\t          front.resolve({\n\t            value: value,\n\t            done: false\n\t          });\n\t          break;\n\t      }\n\t\n\t      front = front.next;\n\t\n\t      if (front) {\n\t        resume(front.key, front.arg);\n\t      } else {\n\t        back = null;\n\t      }\n\t    }\n\t\n\t    this._invoke = send;\n\t\n\t    if (typeof gen.return !== \"function\") {\n\t      this.return = undefined;\n\t    }\n\t  }\n\t\n\t  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n\t    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n\t      return this;\n\t    };\n\t  }\n\t\n\t  AsyncGenerator.prototype.next = function (arg) {\n\t    return this._invoke(\"next\", arg);\n\t  };\n\t\n\t  AsyncGenerator.prototype.throw = function (arg) {\n\t    return this._invoke(\"throw\", arg);\n\t  };\n\t\n\t  AsyncGenerator.prototype.return = function (arg) {\n\t    return this._invoke(\"return\", arg);\n\t  };\n\t\n\t  return {\n\t    wrap: function (fn) {\n\t      return function () {\n\t        return new AsyncGenerator(fn.apply(this, arguments));\n\t      };\n\t    },\n\t    await: function (value) {\n\t      return new AwaitValue(value);\n\t    }\n\t  };\n\t}();\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar get$1 = function get$1(object, property, receiver) {\n\t  if (object === null) object = Function.prototype;\n\t  var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\n\t  if (desc === undefined) {\n\t    var parent = Object.getPrototypeOf(object);\n\t\n\t    if (parent === null) {\n\t      return undefined;\n\t    } else {\n\t      return get$1(parent, property, receiver);\n\t    }\n\t  } else if (\"value\" in desc) {\n\t    return desc.value;\n\t  } else {\n\t    var getter = desc.get;\n\t\n\t    if (getter === undefined) {\n\t      return undefined;\n\t    }\n\t\n\t    return getter.call(receiver);\n\t  }\n\t};\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tvar set$1 = function set$1(object, property, value, receiver) {\n\t  var desc = Object.getOwnPropertyDescriptor(object, property);\n\t\n\t  if (desc === undefined) {\n\t    var parent = Object.getPrototypeOf(object);\n\t\n\t    if (parent !== null) {\n\t      set$1(parent, property, value, receiver);\n\t    }\n\t  } else if (\"value\" in desc && desc.writable) {\n\t    desc.value = value;\n\t  } else {\n\t    var setter = desc.set;\n\t\n\t    if (setter !== undefined) {\n\t      setter.call(receiver, value);\n\t    }\n\t  }\n\t\n\t  return value;\n\t};\n\t\n\tvar _window$2 = window;\n\tvar Node$2 = _window$2.Node;\n\t\n\t\n\tfunction createElement(el) {\n\t  var realNode = document.createElement(el.tagName);\n\t  var attributes = el.attributes;\n\t  var events = el.events;\n\t  var eventHandlers = eventMap(realNode);\n\t  var children = el.childNodes;\n\t\n\t  if (attributes) {\n\t    var attributesLen = attributes.length;\n\t    for (var a = 0; a < attributesLen; a++) {\n\t      var attr = attributes[a];\n\t      setAccessor(realNode, attr.name, attr.value);\n\t    }\n\t  }\n\t\n\t  if (events) {\n\t    for (var name in events) {\n\t      realNode.addEventListener(name, eventHandlers[name] = events[name]);\n\t    }\n\t  }\n\t\n\t  if (children) {\n\t    var docfrag = document.createDocumentFragment();\n\t    var childrenLen = children.length;\n\t\n\t    for (var _a = 0; _a < childrenLen; _a++) {\n\t      var ch = children[_a];\n\t      ch && docfrag.appendChild(render(ch));\n\t    }\n\t\n\t    if (realNode.appendChild) {\n\t      realNode.appendChild(docfrag);\n\t    }\n\t  }\n\t\n\t  return realNode;\n\t}\n\t\n\tfunction createText(el) {\n\t  return document.createTextNode(el.textContent);\n\t}\n\t\n\tfunction render(el) {\n\t  if (el instanceof Node$2) {\n\t    return el;\n\t  }\n\t  if (Array.isArray(el)) {\n\t    var _ret = function () {\n\t      var frag = document.createDocumentFragment();\n\t      el.forEach(function (item) {\n\t        return frag.appendChild(render(item));\n\t      });\n\t      return {\n\t        v: frag\n\t      };\n\t    }();\n\t\n\t    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t  }\n\t  var realNode = el.tagName ? createElement(el) : createText(el);\n\t  realNodeMap.set(el, realNode);\n\t  return realNode;\n\t}\n\t\n\tvar appendChild = function (src, dst) {\n\t  realNode(src).appendChild(render(dst));\n\t};\n\t\n\tvar removeAttribute = function (src, dst, data) {\n\t  removeAccessor(realNode(src), data.name);\n\t};\n\t\n\tvar removeChild = function (src, dst) {\n\t  var realDst = realNode(dst);\n\t  var realSrc = realNode(src);\n\t\n\t  // We don't do parentNode.removeChild because parentNode may report\n\t  // incorrectly in some prollyfills since it's impossible (?) to spoof.\n\t  realSrc.removeChild(realDst);\n\t};\n\t\n\tvar replaceChild = function (src, dst) {\n\t  var realSrc = realNode(src);\n\t  realSrc && realSrc.parentNode && realSrc.parentNode.replaceChild(render(dst), realSrc);\n\t};\n\t\n\tvar setAttribute = function (src, dst, data) {\n\t  setAccessor(realNode(src), data.name, data.value);\n\t};\n\t\n\tvar setEvent = function (src, dst, data) {\n\t  var realSrc = realNode(src);\n\t  var eventHandlers = eventMap(realSrc);\n\t  var name = data.name;\n\t  var prevHandler = eventHandlers[name];\n\t  var nextHandler = data.value;\n\t\n\t  if (typeof prevHandler === 'function') {\n\t    delete eventHandlers[name];\n\t    realSrc.removeEventListener(name, prevHandler);\n\t  }\n\t\n\t  if (typeof nextHandler === 'function') {\n\t    eventHandlers[name] = nextHandler;\n\t    realSrc.addEventListener(name, nextHandler);\n\t  }\n\t};\n\t\n\tvar textContent = function (src, dst) {\n\t  realNode(src).textContent = dst.textContent;\n\t};\n\t\n\tvar patchers = {};\n\tpatchers[APPEND_CHILD] = appendChild;\n\tpatchers[REMOVE_ATTRIBUTE] = removeAttribute;\n\tpatchers[REMOVE_CHILD] = removeChild;\n\tpatchers[REPLACE_CHILD] = replaceChild;\n\tpatchers[SET_ATTRIBUTE] = setAttribute;\n\tpatchers[SET_EVENT] = setEvent;\n\tpatchers[TEXT_CONTENT] = textContent;\n\t\n\tfunction patch(instruction) {\n\t  patchers[instruction.type](instruction.source, instruction.destination, instruction.data);\n\t}\n\t\n\tvar patch$1 = function (instructions) {\n\t  instructions.forEach(patch);\n\t};\n\t\n\tvar merge = function (opts) {\n\t  var inst = diff(opts);\n\t  patch$1(inst);\n\t  return inst;\n\t};\n\t\n\tfunction createTextNode(item) {\n\t  return {\n\t    nodeType: 3,\n\t    textContent: item\n\t  };\n\t}\n\t\n\tfunction separateData(obj) {\n\t  var attrs = {};\n\t  var events = {};\n\t  var node = {};\n\t  var attrIdx = 0;\n\t\n\t  for (var name in obj) {\n\t    var value = obj[name];\n\t\n\t    if (name.indexOf('on') === 0) {\n\t      events[name.substring(2)] = value;\n\t    } else {\n\t      attrs[attrIdx++] = attrs[name] = { name: name, value: value };\n\t      mapAccessor(node, name, value);\n\t    }\n\t  }\n\t\n\t  attrs.length = attrIdx;\n\t  return { attrs: attrs, events: events, node: node };\n\t}\n\t\n\tfunction ensureNodes(arr) {\n\t  var out = [];\n\t  if (!Array.isArray(arr)) {\n\t    arr = [arr];\n\t  }\n\t  arr.filter(Boolean).forEach(function (item) {\n\t    if (Array.isArray(item)) {\n\t      out = out.concat(ensureNodes(item));\n\t    } else if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {\n\t      out.push(translateFromReact(item));\n\t    } else {\n\t      out.push(createTextNode(item));\n\t    }\n\t  });\n\t  return out;\n\t}\n\t\n\tfunction ensureTagName(name) {\n\t  return (typeof name === 'function' ? name.id || name.name : name).toUpperCase();\n\t}\n\t\n\tfunction isChildren(arg) {\n\t  return arg && (typeof arg === 'string' || Array.isArray(arg) || typeof arg.nodeType === 'number' || isReactNode(arg));\n\t}\n\t\n\tfunction isReactNode(item) {\n\t  return item && item.type && item.props;\n\t}\n\t\n\tfunction translateFromReact(item) {\n\t  if (isReactNode(item)) {\n\t    var props = item.props;\n\t    var chren = ensureNodes(props.children);\n\t    delete props.children;\n\t    return {\n\t      nodeType: 1,\n\t      tagName: item.type,\n\t      attributes: props,\n\t      childNodes: chren\n\t    };\n\t  }\n\t  return item;\n\t}\n\t\n\tfunction element(name) {\n\t  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t  var isAttrsNode = isChildren(attrs);\n\t  var data = separateData(isAttrsNode ? {} : attrs);\n\t  var node = data.node;\n\t  node.nodeType = 1;\n\t  node.tagName = ensureTagName(name);\n\t  node.attributes = data.attrs;\n\t  node.events = data.events;\n\t\n\t  for (var _len = arguments.length, chren = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t    chren[_key - 2] = arguments[_key];\n\t  }\n\t\n\t  node.childNodes = ensureNodes(isAttrsNode ? [attrs].concat(chren) : chren);\n\t  return node;\n\t}\n\t\n\t// Add an array factory that returns an array of virtual nodes.\n\telement.array = ensureNodes;\n\t\n\t// Generate built-in factories.\n\t['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'bgsound', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'command', 'content', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'element', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'image', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'multicol', 'nav', 'nobr', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'script', 'section', 'select', 'shadow', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr'].forEach(function (tag) {\n\t  element[tag] = element.bind(null, tag);\n\t});\n\t\n\tfunction removeChildNodes(elem) {\n\t  while (elem.firstChild) {\n\t    var first = elem.firstChild;\n\t    first.parentNode.removeChild(first);\n\t  }\n\t}\n\t\n\tvar mount = function (elem, tree) {\n\t  removeChildNodes(elem);\n\t  elem.appendChild(render(tree));\n\t};\n\t\n\tvar _window$3 = window;\n\tvar Node$3 = _window$3.Node;\n\t\n\tvar oldTreeMap = new WeakMap$1();\n\t\n\tvar render$1 = function (render) {\n\t  return function (elem) {\n\t    elem = elem instanceof Node$3 ? elem : this;\n\t\n\t    if (!(elem instanceof Node$3)) {\n\t      throw new Error('No node provided to diff renderer as either the first argument or the context.');\n\t    }\n\t\n\t    // Create a new element to house the new tree since we diff / mount fragments.\n\t    var newTree = element('div', null, render(elem));\n\t    var oldTree = oldTreeMap.get(elem);\n\t\n\t    if (oldTree) {\n\t      merge({\n\t        destination: newTree,\n\t        source: oldTree\n\t      });\n\t    } else {\n\t      mount(elem, newTree.childNodes);\n\t    }\n\t\n\t    oldTreeMap.set(elem, newTree);\n\t  };\n\t};\n\t\n\tvar vdom = {\n\t  dom: render,\n\t  element: element,\n\t  mount: mount,\n\t  text: createTextNode\n\t};\n\t\n\tvar version = '0.3.1';\n\t\n\tvar index = {\n\t  diff: diff,\n\t  merge: merge,\n\t  patch: patch$1,\n\t  render: render$1,\n\t  types: types,\n\t  vdom: vdom,\n\t  version: version\n\t};\n\t\n\texports['default'] = index;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\t//# sourceMappingURL=index.js.map\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// dist/index-with-deps.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b9adee837d937f2ad333","const { DocumentFragment, Node, Promise } = window;\nconst { slice } = [];\n\nfunction startsWith (key, val) {\n  return key.indexOf(val) === 0;\n}\n\nfunction shouldBeAttr (key, val) {\n  return startsWith(key, 'aria-') || startsWith(key, 'data-');\n}\n\nfunction handleFunction (Fn) {\n  return Fn.prototype instanceof HTMLElement ? new Fn() : Fn();\n}\n\nexport function h (name, attrs, ...chren) {\n  const node = typeof name === 'function' ? handleFunction(name) : document.createElement(name);\n  Object.keys(attrs || []).forEach(attr =>\n    shouldBeAttr(attr, attrs[attr])\n      ? node.setAttribute(attr, attrs[attr])\n      : (node[attr] = attrs[attr]));\n  chren.forEach(child => node.appendChild(child instanceof Node ? child : document.createTextNode(child)));\n  return node;\n}\n\nconst { customElements, HTMLElement, NodeFilter } = window;\nconst { body } = document;\nconst { attachShadow } = HTMLElement.prototype;\nconst { diff } = require('skatejs-dom-diff').default;\n\n// Ensure we can force sync operations in the polyfill.\nif (customElements) {\n  customElements.enableFlush = true;\n}\n\n// Create and add a fixture to append nodes to.\nconst fixture = document.createElement('div');\ndocument.body.appendChild(fixture);\n\n// Override to force mode \"open\" so we can query against all shadow roots.\nHTMLElement.prototype.attachShadow = function () {\n  return attachShadow.call(this, { mode: 'open' });\n};\n\n// Ensures polyfill operations are run sync.\nfunction flush () {\n  if (customElements && typeof customElements.flush === 'function') {\n    customElements.flush();\n  }\n}\n\n// Abstraction for browsers not following the spec.\nfunction matches (node, query) {\n  return (node.matches || node.msMatchesSelector).call(node, query);\n}\n\nclass Wrapper {\n  constructor (node, opts = {}) {\n    this.opts = opts;\n\n    const isStringNode = typeof node === 'string';\n    const isRootNode = !node.parentNode;\n\n    // If the fixture has been removed from the document, re-insert it.\n    if (!body.contains(fixture)) {\n      body.appendChild(fixture);\n    }\n\n    // If this is a new node, clean up the fixture.\n    // Add the node to the fixture so it runs the connectedCallback().\n    if (isRootNode) {\n      fixture.innerHTML = '';\n\n      if (isStringNode) {\n          fixture.innerHTML = node;\n          this.node = fixture.firstElementChild;\n      } else {\n          fixture.appendChild(node);\n          this.node = node;\n      }\n\n      const customElementDefinition = customElements.get(this.node.localName);\n      customElementDefinition && flush();\n    } else {\n      this.node = node;\n    }\n  }\n\n  get shadowRoot () {\n    const { node } = this;\n    return node.shadowRoot || node;\n  }\n\n  all (query) {\n    const { shadowRoot } = this;\n    let temp = [];\n\n    // Custom element constructors\n    if (query.prototype instanceof HTMLElement) {\n      this.walk(\n        shadowRoot,\n        node => node instanceof query,\n        node => temp.push(node)\n      );\n    // Custom filtering function\n    } else if (typeof query === 'function') {\n      this.walk(\n        shadowRoot,\n        query,\n        node => temp.push(node)\n      );\n    // Diffing node trees\n    //\n    // We have to check if the node type is an element rather than checking\n    // instanceof because the ShadyDOM polyfill seems to fail the prototype\n    // chain lookup.\n    } else if (query.nodeType === Node.ELEMENT_NODE) {\n      this.walk(\n        shadowRoot,\n        node => diff({ destination: query, source: node, root: true }).length === 0,\n        node => temp.push(node)\n      );\n    // Using an object as criteria\n    } else if (typeof query === 'object') {\n      const keys = Object.keys(query);\n      if (keys.length === 0) {\n        return temp;\n      }\n      this.walk(\n        shadowRoot,\n        node => keys.every(key => node[key] === query[key]),\n        node => temp.push(node)\n      );\n    // Selector\n    } else if (typeof query === 'string') {\n      this.walk(\n        shadowRoot,\n        node => matches(node, query),\n        node => temp.push(node),\n        { skip: true }\n      );\n    }\n\n    return temp.map(n => new Wrapper(n, this.opts));\n  }\n\n  has (query) {\n    return !!this.one(query);\n  }\n\n  one (query) {\n    return this.all(query)[0];\n  }\n\n  wait (func) {\n    return this.waitFor(wrap => !!wrap.node.shadowRoot).then(func);\n  }\n\n  waitFor (func, { delay } = { delay: 1 }) {\n    return new Promise((resolve, reject) => {\n      const check = () => {\n        const ret = (() => {\n          try {\n            return func(this);\n          } catch (e) {\n            reject(e);\n          }\n        })();\n        if (ret) {\n          resolve(this);\n        } else {\n          setTimeout(check, delay);\n        }\n      };\n      setTimeout(check, delay);\n    }).catch(e => {\n      throw e;\n    });\n  }\n\n  walk (node, query, callback, opts = { root: false, skip: false }) {\n    // The ShadyDOM polyfill creates a shadow root that is a <div /> but is an\n    // instanceof a DocumentFragment. For some reason a tree walker can't\n    // traverse it, so we must traverse each child. Due to this implementation\n    // detail, we must also tell the walker to include the root node, which it\n    // doesn't do with the default implementation.\n    if (node instanceof DocumentFragment) {\n      slice.call(node.children).forEach(child => {\n        this.walk(child, query, callback, {\n          root: true,\n          skip: opts.skip\n        });\n      });\n      return;\n    }\n\n    const acceptNode = node =>\n      query(node)\n        ? NodeFilter.FILTER_ACCEPT\n        : opts.skip ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_REJECT;\n\n    // IE requires a function, standards compliant browsers require an object.\n    acceptNode.acceptNode = acceptNode;\n\n    // Last argument here is for IE.\n    const tree = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, acceptNode, true);\n\n    // Include the main node.\n    if (opts.root && query(node)) {\n      callback(node);\n    }\n\n    // Call user callback for each node.\n    while (tree.nextNode()) {\n      callback(tree.currentNode);\n    }\n  }\n}\n\nexport function mount (elem) {\n  return new Wrapper(elem);\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.skatejsDomDiff = global.skatejsDomDiff || {})));\n}(this, (function (exports) {\n\nvar APPEND_CHILD = 1;\nvar REMOVE_CHILD = 2;\nvar REMOVE_ATTRIBUTE = 3;\nvar REPLACE_CHILD = 4;\nvar SET_ATTRIBUTE = 5;\nvar SET_EVENT = 6;\nvar SET_PROPERTY = 7;\nvar TEXT_CONTENT = 8;\n\nvar types = Object.freeze({\n\tAPPEND_CHILD: APPEND_CHILD,\n\tREMOVE_CHILD: REMOVE_CHILD,\n\tREMOVE_ATTRIBUTE: REMOVE_ATTRIBUTE,\n\tREPLACE_CHILD: REPLACE_CHILD,\n\tSET_ATTRIBUTE: SET_ATTRIBUTE,\n\tSET_EVENT: SET_EVENT,\n\tSET_PROPERTY: SET_PROPERTY,\n\tTEXT_CONTENT: TEXT_CONTENT\n});\n\nfunction classToString(obj) {\n  if (typeof obj === 'string') {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.join(' ');\n  }\n\n  return Object.keys(obj).filter(function (key) {\n    return obj[key] ? key : false;\n  }).join(' ');\n}\n\nfunction styleToString(obj) {\n  if (typeof obj === 'string') {\n    return obj;\n  }\n\n  return Object.keys(obj).map(function (key) {\n    return key + ': ' + obj[key] + ';';\n  }).join(' ');\n}\n\nfunction getAccessor(node, name) {\n  if (name === 'class') {\n    return node.className;\n  } else if (name === 'style') {\n    return node.style.cssText;\n    // most things\n  } else if (name !== 'type' && name in node) {\n    return node[name];\n    // real DOM elements\n  } else if (node.getAttribute) {\n    return node.getAttribute(name);\n    // vDOM nodes\n  } else if (node.attributes && node.attributes[name]) {\n    return node.attributes[name].value;\n  }\n}\n\nfunction mapAccessor(node, name, value) {\n  if (name === 'class') {\n    node.className = classToString(value);\n  } else if (name === 'style') {\n    node.style = { cssText: styleToString(value) };\n  }\n}\n\nfunction removeAccessor(node, name) {\n  if (name === 'class') {\n    node.className = '';\n  } else if (name === 'style') {\n    node.style.cssText = '';\n    // most things\n  } else if (name !== 'type' && name in node) {\n    node[name] = '';\n    // real DOM elements\n  } else if (node.removeAttribute) {\n    node.removeAttribute(name);\n    // vDOM nodes\n  } else if (node.attributes) {\n    delete node.attributes[name];\n  }\n}\n\nfunction setAccessor(node, name, value) {\n  if (name === 'class') {\n    node.className = value;\n  } else if (name === 'style') {\n    node.style.cssText = value;\n    // most things\n  } else if (name !== 'type' && name in node || typeof value !== 'string') {\n    // We check if it's undefined or null because IE throws \"invalid argument\"\n    // errors for some types of properties. Essentially this is the same as\n    // removing the accessor.\n    node[name] = value == null ? '' : value;\n    // real DOM elements\n  } else if (node.setAttribute) {\n    node.setAttribute(name, value);\n    // vDOM nodes\n  } else if (node.attributes) {\n    node.attributes[node.attributes.length] = node.attributes[name] = { name: name, value: value };\n  }\n}\n\nvar compareAttributes = function (src, dst) {\n  var srcAttrs = src.attributes;\n  var dstAttrs = dst.attributes;\n  var srcAttrsLen = (srcAttrs || 0) && srcAttrs.length;\n  var dstAttrsLen = (dstAttrs || 0) && dstAttrs.length;\n  var instructions = [];\n\n  // Bail early if possible.\n  if (!srcAttrsLen && !dstAttrsLen) {\n    return instructions;\n  }\n\n  // Merge attributes that exist in source with destination's.\n  for (var a = 0; a < srcAttrsLen; a++) {\n    var srcAttr = srcAttrs[a];\n    var srcAttrName = srcAttr.name;\n    var srcAttrValue = getAccessor(src, srcAttrName);\n    var dstAttr = dstAttrs[srcAttrName];\n    var dstAttrValue = getAccessor(dst, srcAttrName);\n\n    if (!dstAttr) {\n      instructions.push({\n        data: { name: srcAttrName },\n        destination: dst,\n        source: src,\n        type: REMOVE_ATTRIBUTE\n      });\n    } else if (srcAttrValue !== dstAttrValue) {\n      instructions.push({\n        data: { name: srcAttrName, value: dstAttrValue },\n        destination: dst,\n        source: src,\n        type: SET_ATTRIBUTE\n      });\n    }\n  }\n\n  // We only need to worry about setting attributes that don't already exist\n  // in the source.\n  for (var _a = 0; _a < dstAttrsLen; _a++) {\n    var _dstAttr = dstAttrs[_a];\n    var dstAttrName = _dstAttr.name;\n    var _dstAttrValue = getAccessor(dst, dstAttrName);\n    var _srcAttr = srcAttrs[dstAttrName];\n\n    if (!_srcAttr) {\n      instructions.push({\n        data: { name: dstAttrName, value: _dstAttrValue },\n        destination: dst,\n        source: src,\n        type: SET_ATTRIBUTE\n      });\n    }\n  }\n\n  return instructions;\n};\n\n// Because weak map polyfills either are too big or don't use native if\n// available properly.\n\nvar index$1 = 0;\nvar prefix = '__WEAK_MAP_POLYFILL_';\n\nvar WeakMap$1 = (function () {\n  if (typeof WeakMap !== 'undefined') {\n    return WeakMap;\n  }\n\n  function Polyfill() {\n    this.key = prefix + index$1;\n    ++index$1;\n  }\n\n  Polyfill.prototype = {\n    get: function get(obj) {\n      return obj[this.key];\n    },\n    set: function set(obj, val) {\n      obj[this.key] = val;\n    }\n  };\n\n  return Polyfill;\n})();\n\nvar map = new WeakMap$1();\n\nvar eventMap = function (elem) {\n  var events = map.get(elem);\n  events || map.set(elem, events = {});\n  return events;\n};\n\nvar compareEvents = function (src, dst) {\n  var dstEvents = dst.events;\n  var srcEvents = eventMap(src);\n  var instructions = [];\n\n  // Remove any source events that aren't in the destination before seeing if\n  // we need to add any from the destination.\n  if (srcEvents) {\n    for (var name in srcEvents) {\n      if (dstEvents && dstEvents[name] !== srcEvents[name]) {\n        instructions.push({\n          data: { name: name, value: undefined },\n          destination: dst,\n          source: src,\n          type: SET_EVENT\n        });\n      }\n    }\n  }\n\n  // After instructing to remove any old events, we then can instruct to add\n  // new events. This prevents the new events from being removed from earlier\n  // instructions.\n  if (dstEvents) {\n    for (var _name in dstEvents) {\n      var value = dstEvents[_name];\n      if (srcEvents[_name] !== value) {\n        instructions.push({\n          data: { name: _name, value: value },\n          destination: dst,\n          source: src,\n          type: SET_EVENT\n        });\n      }\n    }\n  }\n\n  return instructions;\n};\n\nvar compareElement = function (src, dst) {\n  if (src.tagName === dst.tagName) {\n    return compareAttributes(src, dst).concat(compareEvents(src, dst));\n  }\n};\n\nvar text = function (src, dst) {\n  if (src.textContent === dst.textContent) {\n    return [];\n  }\n\n  return [{\n    destination: dst,\n    source: src,\n    type: TEXT_CONTENT\n  }];\n};\n\nvar NODE_COMMENT = 8;\nvar NODE_ELEMENT = 1;\nvar NODE_TEXT = 3;\n\nvar compareNode = function (src, dst) {\n  var dstType = void 0,\n      srcType = void 0;\n\n  if (!dst || !src) {\n    return;\n  }\n\n  dstType = dst.nodeType;\n  srcType = src.nodeType;\n\n  if (dstType !== srcType) {\n    return;\n  } else if (dstType === NODE_ELEMENT) {\n    return compareElement(src, dst);\n  } else if (dstType === NODE_TEXT) {\n    return text(src, dst);\n  } else if (dstType === NODE_COMMENT) {\n    return text(src, dst);\n  }\n};\n\nvar realNodeMap = new WeakMap$1();\n\nvar _window$1 = window;\nvar Node$1 = _window$1.Node;\n\n\nvar realNode = function (node) {\n  return node instanceof Node$1 ? node : realNodeMap.get(node);\n};\n\nvar _window = window;\nvar Node = _window.Node;\n\n\nfunction diffNode(source, destination) {\n  var nodeInstructions = compareNode(source, destination);\n\n  // If there are instructions (even an empty array) it means the node can be\n  // diffed and doesn't have to be replaced. If the instructions are falsy\n  // it means that the nodes are not similar (cannot be changed) and must be\n  // replaced instead.\n  if (nodeInstructions) {\n    return nodeInstructions.concat(diff({ source: source, destination: destination }));\n  }\n\n  return [{\n    destination: destination,\n    source: source,\n    type: REPLACE_CHILD\n  }];\n}\n\nfunction diff() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var src = opts.source;\n  var dst = opts.destination;\n\n  if (!src || !dst) {\n    return [];\n  }\n\n  var instructions = opts.root ? diffNode(src, dst) : [];\n\n  var srcChs = src.childNodes;\n  var dstChs = dst.childNodes;\n  var srcChsLen = srcChs ? srcChs.length : 0;\n  var dstChsLen = dstChs ? dstChs.length : 0;\n\n  for (var a = 0; a < dstChsLen; a++) {\n    var curSrc = srcChs[a];\n    var curDst = dstChs[a];\n\n    // If there is no matching destination node it means we need to remove the\n    // current source node from the source.\n    if (!curSrc) {\n      instructions.push({\n        destination: dstChs[a],\n        source: src,\n        type: APPEND_CHILD\n      });\n      continue;\n    } else {\n      // Ensure the real node is carried over even if the destination isn't used.\n      // This is used in the render() function to keep track of the real node\n      // that corresponds to a virtual node if a virtual tree is being used.\n      if (!(curDst instanceof Node)) {\n        realNodeMap.set(curDst, realNode(curSrc));\n      }\n    }\n\n    instructions = instructions.concat(diffNode(curSrc, curDst));\n  }\n\n  if (dstChsLen < srcChsLen) {\n    for (var _a = dstChsLen; _a < srcChsLen; _a++) {\n      instructions.push({\n        destination: srcChs[_a],\n        source: src,\n        type: REMOVE_CHILD\n      });\n    }\n  }\n\n  return instructions;\n}\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\nvar asyncGenerator = function () {\n  function AwaitValue(value) {\n    this.value = value;\n  }\n\n  function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg);\n        var value = result.value;\n\n        if (value instanceof AwaitValue) {\n          Promise.resolve(value.value).then(function (arg) {\n            resume(\"next\", arg);\n          }, function (arg) {\n            resume(\"throw\", arg);\n          });\n        } else {\n          settle(result.done ? \"return\" : \"normal\", result.value);\n        }\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({\n            value: value,\n            done: true\n          });\n          break;\n\n        case \"throw\":\n          front.reject(value);\n          break;\n\n        default:\n          front.resolve({\n            value: value,\n            done: false\n          });\n          break;\n      }\n\n      front = front.next;\n\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  if (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n    AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n\n  AsyncGenerator.prototype.next = function (arg) {\n    return this._invoke(\"next\", arg);\n  };\n\n  AsyncGenerator.prototype.throw = function (arg) {\n    return this._invoke(\"throw\", arg);\n  };\n\n  AsyncGenerator.prototype.return = function (arg) {\n    return this._invoke(\"return\", arg);\n  };\n\n  return {\n    wrap: function (fn) {\n      return function () {\n        return new AsyncGenerator(fn.apply(this, arguments));\n      };\n    },\n    await: function (value) {\n      return new AwaitValue(value);\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar get$1 = function get$1(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get$1(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar set$1 = function set$1(object, property, value, receiver) {\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent !== null) {\n      set$1(parent, property, value, receiver);\n    }\n  } else if (\"value\" in desc && desc.writable) {\n    desc.value = value;\n  } else {\n    var setter = desc.set;\n\n    if (setter !== undefined) {\n      setter.call(receiver, value);\n    }\n  }\n\n  return value;\n};\n\nvar _window$2 = window;\nvar Node$2 = _window$2.Node;\n\n\nfunction createElement(el) {\n  var realNode = document.createElement(el.tagName);\n  var attributes = el.attributes;\n  var events = el.events;\n  var eventHandlers = eventMap(realNode);\n  var children = el.childNodes;\n\n  if (attributes) {\n    var attributesLen = attributes.length;\n    for (var a = 0; a < attributesLen; a++) {\n      var attr = attributes[a];\n      setAccessor(realNode, attr.name, attr.value);\n    }\n  }\n\n  if (events) {\n    for (var name in events) {\n      realNode.addEventListener(name, eventHandlers[name] = events[name]);\n    }\n  }\n\n  if (children) {\n    var docfrag = document.createDocumentFragment();\n    var childrenLen = children.length;\n\n    for (var _a = 0; _a < childrenLen; _a++) {\n      var ch = children[_a];\n      ch && docfrag.appendChild(render(ch));\n    }\n\n    if (realNode.appendChild) {\n      realNode.appendChild(docfrag);\n    }\n  }\n\n  return realNode;\n}\n\nfunction createText(el) {\n  return document.createTextNode(el.textContent);\n}\n\nfunction render(el) {\n  if (el instanceof Node$2) {\n    return el;\n  }\n  if (Array.isArray(el)) {\n    var _ret = function () {\n      var frag = document.createDocumentFragment();\n      el.forEach(function (item) {\n        return frag.appendChild(render(item));\n      });\n      return {\n        v: frag\n      };\n    }();\n\n    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n  }\n  var realNode = el.tagName ? createElement(el) : createText(el);\n  realNodeMap.set(el, realNode);\n  return realNode;\n}\n\nvar appendChild = function (src, dst) {\n  realNode(src).appendChild(render(dst));\n};\n\nvar removeAttribute = function (src, dst, data) {\n  removeAccessor(realNode(src), data.name);\n};\n\nvar removeChild = function (src, dst) {\n  var realDst = realNode(dst);\n  var realSrc = realNode(src);\n\n  // We don't do parentNode.removeChild because parentNode may report\n  // incorrectly in some prollyfills since it's impossible (?) to spoof.\n  realSrc.removeChild(realDst);\n};\n\nvar replaceChild = function (src, dst) {\n  var realSrc = realNode(src);\n  realSrc && realSrc.parentNode && realSrc.parentNode.replaceChild(render(dst), realSrc);\n};\n\nvar setAttribute = function (src, dst, data) {\n  setAccessor(realNode(src), data.name, data.value);\n};\n\nvar setEvent = function (src, dst, data) {\n  var realSrc = realNode(src);\n  var eventHandlers = eventMap(realSrc);\n  var name = data.name;\n  var prevHandler = eventHandlers[name];\n  var nextHandler = data.value;\n\n  if (typeof prevHandler === 'function') {\n    delete eventHandlers[name];\n    realSrc.removeEventListener(name, prevHandler);\n  }\n\n  if (typeof nextHandler === 'function') {\n    eventHandlers[name] = nextHandler;\n    realSrc.addEventListener(name, nextHandler);\n  }\n};\n\nvar textContent = function (src, dst) {\n  realNode(src).textContent = dst.textContent;\n};\n\nvar patchers = {};\npatchers[APPEND_CHILD] = appendChild;\npatchers[REMOVE_ATTRIBUTE] = removeAttribute;\npatchers[REMOVE_CHILD] = removeChild;\npatchers[REPLACE_CHILD] = replaceChild;\npatchers[SET_ATTRIBUTE] = setAttribute;\npatchers[SET_EVENT] = setEvent;\npatchers[TEXT_CONTENT] = textContent;\n\nfunction patch(instruction) {\n  patchers[instruction.type](instruction.source, instruction.destination, instruction.data);\n}\n\nvar patch$1 = function (instructions) {\n  instructions.forEach(patch);\n};\n\nvar merge = function (opts) {\n  var inst = diff(opts);\n  patch$1(inst);\n  return inst;\n};\n\nfunction createTextNode(item) {\n  return {\n    nodeType: 3,\n    textContent: item\n  };\n}\n\nfunction separateData(obj) {\n  var attrs = {};\n  var events = {};\n  var node = {};\n  var attrIdx = 0;\n\n  for (var name in obj) {\n    var value = obj[name];\n\n    if (name.indexOf('on') === 0) {\n      events[name.substring(2)] = value;\n    } else {\n      attrs[attrIdx++] = attrs[name] = { name: name, value: value };\n      mapAccessor(node, name, value);\n    }\n  }\n\n  attrs.length = attrIdx;\n  return { attrs: attrs, events: events, node: node };\n}\n\nfunction ensureNodes(arr) {\n  var out = [];\n  if (!Array.isArray(arr)) {\n    arr = [arr];\n  }\n  arr.filter(Boolean).forEach(function (item) {\n    if (Array.isArray(item)) {\n      out = out.concat(ensureNodes(item));\n    } else if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {\n      out.push(translateFromReact(item));\n    } else {\n      out.push(createTextNode(item));\n    }\n  });\n  return out;\n}\n\nfunction ensureTagName(name) {\n  return (typeof name === 'function' ? name.id || name.name : name).toUpperCase();\n}\n\nfunction isChildren(arg) {\n  return arg && (typeof arg === 'string' || Array.isArray(arg) || typeof arg.nodeType === 'number' || isReactNode(arg));\n}\n\nfunction isReactNode(item) {\n  return item && item.type && item.props;\n}\n\nfunction translateFromReact(item) {\n  if (isReactNode(item)) {\n    var props = item.props;\n    var chren = ensureNodes(props.children);\n    delete props.children;\n    return {\n      nodeType: 1,\n      tagName: item.type,\n      attributes: props,\n      childNodes: chren\n    };\n  }\n  return item;\n}\n\nfunction element(name) {\n  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var isAttrsNode = isChildren(attrs);\n  var data = separateData(isAttrsNode ? {} : attrs);\n  var node = data.node;\n  node.nodeType = 1;\n  node.tagName = ensureTagName(name);\n  node.attributes = data.attrs;\n  node.events = data.events;\n\n  for (var _len = arguments.length, chren = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    chren[_key - 2] = arguments[_key];\n  }\n\n  node.childNodes = ensureNodes(isAttrsNode ? [attrs].concat(chren) : chren);\n  return node;\n}\n\n// Add an array factory that returns an array of virtual nodes.\nelement.array = ensureNodes;\n\n// Generate built-in factories.\n['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'bgsound', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'command', 'content', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'element', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'image', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'multicol', 'nav', 'nobr', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'rtc', 'ruby', 's', 'samp', 'script', 'section', 'select', 'shadow', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr'].forEach(function (tag) {\n  element[tag] = element.bind(null, tag);\n});\n\nfunction removeChildNodes(elem) {\n  while (elem.firstChild) {\n    var first = elem.firstChild;\n    first.parentNode.removeChild(first);\n  }\n}\n\nvar mount = function (elem, tree) {\n  removeChildNodes(elem);\n  elem.appendChild(render(tree));\n};\n\nvar _window$3 = window;\nvar Node$3 = _window$3.Node;\n\nvar oldTreeMap = new WeakMap$1();\n\nvar render$1 = function (render) {\n  return function (elem) {\n    elem = elem instanceof Node$3 ? elem : this;\n\n    if (!(elem instanceof Node$3)) {\n      throw new Error('No node provided to diff renderer as either the first argument or the context.');\n    }\n\n    // Create a new element to house the new tree since we diff / mount fragments.\n    var newTree = element('div', null, render(elem));\n    var oldTree = oldTreeMap.get(elem);\n\n    if (oldTree) {\n      merge({\n        destination: newTree,\n        source: oldTree\n      });\n    } else {\n      mount(elem, newTree.childNodes);\n    }\n\n    oldTreeMap.set(elem, newTree);\n  };\n};\n\nvar vdom = {\n  dom: render,\n  element: element,\n  mount: mount,\n  text: createTextNode\n};\n\nvar version = '0.3.1';\n\nvar index = {\n  diff: diff,\n  merge: merge,\n  patch: patch$1,\n  render: render$1,\n  types: types,\n  vdom: vdom,\n  version: version\n};\n\nexports['default'] = index;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=index.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/skatejs-dom-diff/dist/index.js\n// module id = 1\n// module chunks = 0 1"],"sourceRoot":""}