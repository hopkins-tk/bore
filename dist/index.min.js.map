{"version":3,"file":null,"sources":["../src/index.js"],"sourcesContent":["const { DocumentFragment, Node, Promise } = window;\nconst { slice } = [];\n\nfunction startsWith (key, val) {\n  return key.indexOf(val) === 0;\n}\n\nfunction shouldBeAttr (key, val) {\n  return startsWith(key, 'aria-') || startsWith(key, 'data-');\n}\n\nfunction handleFunction (Fn) {\n  return Fn.prototype instanceof HTMLElement ? new Fn() : Fn();\n}\n\nexport function h (name, attrs, ...chren) {\n  const node = typeof name === 'function' ? handleFunction(name) : document.createElement(name);\n  Object.keys(attrs || []).forEach(attr =>\n    shouldBeAttr(attr, attrs[attr])\n      ? node.setAttribute(attr, attrs[attr])\n      : (node[attr] = attrs[attr]));\n  chren.forEach(child => node.appendChild(child instanceof Node ? child : document.createTextNode(child)));\n  return node;\n}\n\nconst { customElements, HTMLElement, NodeFilter } = window;\nconst { body } = document;\nconst { attachShadow } = HTMLElement.prototype;\nconst { diff } = require('skatejs-dom-diff').default;\n\n// Ensure we can force sync operations in the polyfill.\nif (customElements) {\n  customElements.enableFlush = true;\n}\n\n// Create and add a fixture to append nodes to.\nconst fixture = document.createElement('div');\ndocument.body.appendChild(fixture);\n\n// Override to force mode \"open\" so we can query against all shadow roots.\nHTMLElement.prototype.attachShadow = function () {\n  return attachShadow.call(this, { mode: 'open' });\n};\n\n// Ensures polyfill operations are run sync.\nfunction flush () {\n  if (customElements && typeof customElements.flush === 'function') {\n    customElements.flush();\n  }\n}\n\n// Abstraction for browsers not following the spec.\nfunction matches (node, query) {\n  return (node.matches || node.msMatchesSelector).call(node, query);\n}\n\nclass Wrapper {\n  constructor (node, opts = {}) {\n    this.opts = opts;\n\n    const isStringNode = typeof node === 'string';\n    const isRootNode = !node.parentNode;\n\n    // If the fixture has been removed from the document, re-insert it.\n    if (!body.contains(fixture)) {\n      body.appendChild(fixture);\n    }\n\n    // If this is a new node, clean up the fixture.\n    // Add the node to the fixture so it runs the connectedCallback().\n    if (isRootNode) {\n      fixture.innerHTML = '';\n\n      if (isStringNode) {\n          fixture.innerHTML = node;\n          this.node = fixture.firstElementChild;\n      } else {\n          fixture.appendChild(node);\n          this.node = node;\n      }\n\n      const customElementDefinition = customElements.get(this.node.localName);\n      customElementDefinition && flush();\n    } else {\n      this.node = node;\n    }\n  }\n\n  get shadowRoot () {\n    const { node } = this;\n    return node.shadowRoot || node;\n  }\n\n  all (query) {\n    const { shadowRoot } = this;\n    let temp = [];\n\n    // Custom element constructors\n    if (query.prototype instanceof HTMLElement) {\n      this.walk(\n        shadowRoot,\n        node => node instanceof query,\n        node => temp.push(node)\n      );\n    // Custom filtering function\n    } else if (typeof query === 'function') {\n      this.walk(\n        shadowRoot,\n        query,\n        node => temp.push(node)\n      );\n    // Diffing node trees\n    //\n    // We have to check if the node type is an element rather than checking\n    // instanceof because the ShadyDOM polyfill seems to fail the prototype\n    // chain lookup.\n    } else if (query.nodeType === Node.ELEMENT_NODE) {\n      this.walk(\n        shadowRoot,\n        node => diff({ destination: query, source: node, root: true }).length === 0,\n        node => temp.push(node)\n      );\n    // Using an object as criteria\n    } else if (typeof query === 'object') {\n      const keys = Object.keys(query);\n      if (keys.length === 0) {\n        return temp;\n      }\n      this.walk(\n        shadowRoot,\n        node => keys.every(key => node[key] === query[key]),\n        node => temp.push(node)\n      );\n    // Selector\n    } else if (typeof query === 'string') {\n      this.walk(\n        shadowRoot,\n        node => matches(node, query),\n        node => temp.push(node),\n        { skip: true }\n      );\n    }\n\n    return temp.map(n => new Wrapper(n, this.opts));\n  }\n\n  has (query) {\n    return !!this.one(query);\n  }\n\n  one (query) {\n    return this.all(query)[0];\n  }\n\n  wait (func) {\n    return this.waitFor(wrap => !!wrap.node.shadowRoot).then(func);\n  }\n\n  waitFor (func, { delay } = { delay: 1 }) {\n    return new Promise((resolve, reject) => {\n      const check = () => {\n        const ret = (() => {\n          try {\n            return func(this);\n          } catch (e) {\n            reject(e);\n          }\n        })();\n        if (ret) {\n          resolve(this);\n        } else {\n          setTimeout(check, delay);\n        }\n      };\n      setTimeout(check, delay);\n    }).catch(e => {\n      throw e;\n    });\n  }\n\n  walk (node, query, callback, opts = { root: false, skip: false }) {\n    // The ShadyDOM polyfill creates a shadow root that is a <div /> but is an\n    // instanceof a DocumentFragment. For some reason a tree walker can't\n    // traverse it, so we must traverse each child. Due to this implementation\n    // detail, we must also tell the walker to include the root node, which it\n    // doesn't do with the default implementation.\n    if (node instanceof DocumentFragment) {\n      slice.call(node.children).forEach(child => {\n        this.walk(child, query, callback, {\n          root: true,\n          skip: opts.skip\n        });\n      });\n      return;\n    }\n\n    const acceptNode = node =>\n      query(node)\n        ? NodeFilter.FILTER_ACCEPT\n        : opts.skip ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_REJECT;\n\n    // IE requires a function, standards compliant browsers require an object.\n    acceptNode.acceptNode = acceptNode;\n\n    // Last argument here is for IE.\n    const tree = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT, acceptNode, true);\n\n    // Include the main node.\n    if (opts.root && query(node)) {\n      callback(node);\n    }\n\n    // Call user callback for each node.\n    while (tree.nextNode()) {\n      callback(tree.currentNode);\n    }\n  }\n}\n\nexport function mount (elem) {\n  return new Wrapper(elem);\n}\n"],"names":["startsWith","key","val","indexOf","shouldBeAttr","handleFunction","Fn","prototype","HTMLElement","h","name","attrs","node","document","createElement","keys","forEach","attr","setAttribute","chren","appendChild","child","Node","createTextNode","flush","customElements","matches","query","msMatchesSelector","call","mount","elem","Wrapper","window","DocumentFragment","Promise","slice","NodeFilter","body","attachShadow","diff","require","default","enableFlush","fixture","this","mode","opts","isStringNode","isRootNode","parentNode","contains","innerHTML","firstElementChild","customElementDefinition","get","localName","shadowRoot","temp","walk","push","nodeType","ELEMENT_NODE","destination","source","root","length","Object","every","skip","map","n","_this","one","all","func","waitFor","wrap","then","delay","resolve","reject","check","ret","e","catch","callback","children","acceptNode","FILTER_ACCEPT","FILTER_SKIP","FILTER_REJECT","tree","createTreeWalker","SHOW_ELEMENT","nextNode","currentNode"],"mappings":"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"}